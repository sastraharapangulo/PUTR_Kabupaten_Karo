const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/CatalogLayer-DxAB4jxi.js","assets/index-CdyqwYB1.js","assets/index-CxJz3tXl.css","assets/utils-gLFLXtPf.js","assets/ClassBreaksDefinition-DVS2istx.js","assets/FeatureLayerBase-C4EHSHPu.js","assets/LayerFloorInfo-DwdsiYy5.js","assets/Relationship-DdWfDoOE.js","assets/serviceCapabilitiesUtils-COmh7_7j.js","assets/infoFor3D-dHKPbXlj.js","assets/FeatureLayerSource-Bvs5oLkY.js","assets/MeshLocalVertexSpace-v_Brcy1u.js","assets/meshVertexSpaceUtils-CVwVUWgR.js","assets/External-D-jjQ9UV.js","assets/MeshTransform-Dn54nHH6.js","assets/mat4f64-Dk4dwAN8.js","assets/quat-RO2z-Ojv.js","assets/mat3f64-q3fE-ZOt.js","assets/quatf64-aQ5IuZRd.js","assets/axisAngleDegrees-Dgi7-80E.js","assets/editingSupport-CNBp2NXa.js","assets/EditBusLayer-CrTbG9mC.js","assets/QueryTask-Uc_MlfvI.js","assets/executeForIds-B3liS11N.js","assets/query-CARyVpMP.js","assets/pbfQueryUtils-DjqEhsNx.js","assets/pbf-Cq7PxY-8.js","assets/OptimizedFeature-wY9c6auI.js","assets/OptimizedFeatureSet-Blu9Ckm7.js","assets/queryZScale-BguiU5fa.js","assets/executeQueryJSON-DBbv7XCk.js","assets/featureConversionUtils-76XyQOp_.js","assets/editsZScale-DXBMVKIv.js","assets/FeatureType-IyOulWM1.js","assets/versionUtils-LQ6juH9y.js","assets/FeatureLayer-CN-E-37P.js","assets/TitleCreator-BhJJakUn.js","assets/styleUtils-B1K7dr4M.js","assets/interfaces-CL2NbQte.js","assets/OrientedImageryLayer-BZ77M78g.js"])))=>i.map(i=>d[i]);
import{d as m,ca as k,fR as O,b as u,fS as B,fT as f,fU as K,fV as y,eM as z,fW as j,_ as P,fX as W}from"./index-CdyqwYB1.js";import{i as w}from"./originUtils-D69mHv66.js";import{P as X,w as x,d as q,v as H,$ as Q,p as N,f as Z,I as g,m as L}from"./utils-DdEiCD9C.js";import{a as aa,i as ea}from"./fetchService-CWTub-CO.js";import"./multiOriginJSONSupportUtils-C0wm8_Yw.js";import"./saveUtils-C4qLftUE.js";const v="Feature Service",T="feature-layer-utils",ta=`${T}-save`,ra=`${T}-save-as`,p=`${T}-saveall`,d=`${T}-saveall-as`;function $(a){return{isValid:W(a)&&(!("dynamicDataSource"in a)||!a.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function b(a,e){const t=B(a,"portal-item");return e!=null&&e.isTable&&(t.layerContainerType="tables"),t}function R(a){const e=b(a),t=b(a);return t.layerContainerType="tables",{forLayers:e,forTables:t}}function D(a){const e=[],t=[];for(const{layer:r,layerJSON:o}of a)r.isTable?t.push(o):e.push(o);return{layers:e,tables:t}}function J(a){return D([a])}async function U(a,e){return/\/\d+\/?$/.test(a.url)?J(e[0]):G(e,a)}async function G(a,e){if(a.reverse(),!e)return D(a);const t=await sa(e,a);for(const r of a)M(r.layer,r.layerJSON,t);return la(t,a),t}async function sa(a,e){let t=await a.fetchData("json");if(na(t))return t;t||(t={}),oa(t);const{layer:{url:r,customParameters:o,apiKey:s}}=e[0];return await ia(t,{url:r??"",customParameters:o,apiKey:s},e.map(n=>n.layer.layerId)),t}function na(a){return!!(a&&Array.isArray(a.layers)&&Array.isArray(a.tables))}function oa(a){a.layers||(a.layers=[]),a.tables||(a.tables=[])}function la(a,e){const t=[],r=[];for(const{layer:o}of e){const{isTable:s,layerId:n}=o;s?r.push(n):t.push(n)}S(a.layers,t),S(a.tables,r)}function S(a,e){if(a.length<2)return;const t=[];for(const{id:r}of a)t.push(r);z(t.sort(E),e.slice().sort(E))&&a.sort((r,o)=>{const s=e.indexOf(r.id),n=e.indexOf(o.id);return s<n?-1:s>n?1:0})}function E(a,e){return a<e?-1:a>e?1:0}async function ia(a,e,t){const{url:r,customParameters:o,apiKey:s}=e,{serviceJSON:n,layersJSON:l}=await aa(r,{customParameters:o,apiKey:s}),i=_(a.layers,n.layers,t),c=_(a.tables,n.tables,t);a.layers=i.itemResources,a.tables=c.itemResources;const h=[...i.added,...c.added],V=l?[...l.layers,...l.tables]:[];await ca(a,h,r,V)}function _(a,e,t){const r=j(a,e,(s,n)=>s.id===n.id);a=a.filter(s=>!r.removed.some(n=>n.id===s.id));const o=r.added;return o.forEach(({id:s})=>{a.push({id:s})}),{itemResources:a,added:o.filter(({id:s})=>!t.includes(s))}}async function ca(a,e,t,r){const o=await ua(e),s=e.map(({id:n,type:l})=>new(o.get(l))({url:t,layerId:n,sourceJSON:r.find(({id:i})=>i===n)}));await Promise.allSettled(s.map(n=>n.load())),s.forEach(n=>{const{layerId:l,loaded:i,defaultPopupTemplate:c}=n;if(!i||c==null)return;const h={id:l,popupInfo:c.toJSON()};n.operationalLayerType!=="ArcGISFeatureLayer"&&(h.layerType=n.operationalLayerType),M(n,h,a)})}async function ua(a){const e=[];a.forEach(({type:o})=>{switch(ea(o)){case"CatalogLayer":e.push(P(()=>import("./CatalogLayer-DxAB4jxi.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34])).then(s=>s.default));break;case"FeatureLayer":e.push(P(()=>import("./FeatureLayer-CN-E-37P.js"),__vite__mapDeps([35,1,2,5,6,7,8,9,32,29,21,33,36,34,37,38])).then(s=>s.default));break;case"OrientedImageryLayer":e.push(P(()=>import("./OrientedImageryLayer-BZ77M78g.js"),__vite__mapDeps([39,1,2,35,5,6,7,8,9,32,29,21,33,36,34,37,38])).then(s=>s.default))}});const t=await Promise.all(e),r=new Map;return a.forEach(({type:o},s)=>{r.set(o,t[s])}),r}function M(a,e,t){a.isTable?A(t.tables,e):A(t.layers,e)}function A(a,e){const t=a.findIndex(({id:r})=>r===e.id);t===-1?a.push(e):a[t]=e}function F(a,e){if(!a.length)throw new u(`${e}:missing-parameters`,"'layers' array should contain at least one feature layer")}function ya(a,e){const t=a.map(r=>r.portalItem.id);if(new Set(t).size>1)throw new u(`${e}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function Y(a,e){const t=a.map(r=>r.layerId);if(new Set(t).size!==t.length)throw new u(`${e}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function fa(a){F(a,p),await Promise.all(a.map(e=>e.load()));for(const e of a)N(e,p,$),Z({layer:e,itemType:v,errorNamePrefix:p});ya(a,p),Y(a,p)}function I(a,e){let t=0,r=0,o=0;for(const{layerType:s}of[...e.layers,...e.tables])switch(s){case"OrientedImageryLayer":t++;break;case"SubtypeGroupLayer":r++;break;case"SubtypeGroupTable":o++}f(a,y.ORIENTED_IMAGERY_LAYER,t>0),f(a,y.SUBTYPE_GROUP_LAYER,r>0),f(a,y.SUBTYPE_GROUP_TABLE,o>0)}function C(a,e,t){K(e,y.METADATA),f(e,y.MULTI_LAYER,a.length>1),f(e,y.SINGLE_LAYER,a.length===1),f(e,y.TABLE,t.tables.length>0&&t.layers.length===0),I(e,t)}async function pa(a,e,t){I(e,t)}async function da(a,e,t){const{url:r,layerId:o,title:s,fullExtent:n,isTable:l}=a,i=m(r);e.url=((i==null?void 0:i.serverType)==="FeatureServer"?r:`${r}/${o}`)??null,e.title||(e.title=s),e.extent=null,l||n==null||(e.extent=await O(n)),C([a],e,t)}function ma(a,e){for(const s of a){const n=s.parsedUrl.path,l=m(n);if(!(l==null?void 0:l.url.path))throw new u(`${e}:invalid-parameters`,L(s,`has unsupported url pattern: ${n}`),{layer:s});const c=l==null?void 0:l.serverType;if(c!=="FeatureServer"&&c!=="MapServer")throw new u(`${e}:invalid-parameters`,L(s,`has unsupported server type: ${c}`),{layer:s});if(c==="MapServer"&&a.length>1)throw new u(`${e}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const t=m(a[0].parsedUrl.path),r=t==null?void 0:t.url.path;if(!a.every(s=>{const n=m(s.parsedUrl.path);return(n==null?void 0:n.url.path)===r}))throw new u(`${e}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function ha(a){F(a,d),await Promise.all(a.map(e=>e.load()));for(const e of a)N(e,d,$);ma(a,d),Y(a,d)}function wa(a,e){I(a,e),g(a)}async function ba(a,e,t){let r=0;for(const{isTable:n}of a)n||r++;const o=a[0].parsedUrl.path,s=m(o);if(e.url=(s==null?void 0:s.serverType)==="FeatureServer"?s.url.path:o,e.title||(e.title=s.title),e.extent=null,r>0){const n=a.map(l=>l.fullExtent).filter(k).reduce((l,i)=>l.clone().union(i));n&&(e.extent=await O(n))}C(a,e,t),g(e)}async function Sa(a,e){return X({layer:a,itemType:v,validateLayer:$,createJSONContext:t=>b(t,a),createItemData:(t,r)=>U(r,[t]),errorNamePrefix:ta,setItemProperties:pa},e)}async function Ea(a,e){await fa(a);const t=a[0].portalItem,r=R(t),o=await Promise.all(a.map(n=>x(n,n.isTable?r.forTables:r.forLayers,e))),s=await U(t,a.map((n,l)=>({layer:n,layerJSON:o[l]})));return wa(t,s),await t.update({data:s}),await Promise.all(a.slice(1).map(n=>n.portalItem.reload())),w(r.forLayers),w(r.forTables),t.clone()}async function _a(a,e,t){return Q({layer:a,itemType:v,validateLayer:$,createJSONContext:r=>b(r,a),createItemData:(r,o)=>Promise.resolve(J(r)),errorNamePrefix:ra,newItem:e,setItemProperties:da},t)}async function Aa(a,e,t){await ha(a);const r=q({itemType:v,errorNamePrefix:d,newItem:e}),o=R(r),s=await Promise.all(a.map(l=>x(l,l.isTable?o.forTables:o.forLayers,t))),n=await G(a.map((l,i)=>({layer:l,layerJSON:s[i]})));await ba(a,r,n),await H(r,n,t);for(const l of a)l.portalItem=r.clone();return w(o.forLayers),w(o.forTables),r}export{Sa as save,Ea as saveAll,Aa as saveAllAs,_a as saveAs};

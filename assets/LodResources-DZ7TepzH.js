import{ea as D,ds as L,jC as A,ee as N,eu as R,er as P,ef as S,e0 as z,eb as v,jx as J,jy as H,eV as X,hz as $,lB as G,aR as K,gK as Q}from"./index-D805BexR.js";import{o as V,e as k}from"./mat4f64-Dk4dwAN8.js";import{b as p,S as q,v as T}from"./sphere-CdMHh-xJ.js";import{s as F,e as w,i as f}from"./IntersectorInterfaces-CmNINbyF.js";import"./boundedPlane-D4h-xIAT.js";import{b as Y,d as I}from"./Geometry-CFCBzhi6.js";import{e as Z}from"./VertexAttribute-Cq4MnHjR.js";class tt{constructor(t,e,r){this.object=t,this.geometryId=e,this.triangleNr=r}}class et extends tt{constructor(t,e,r,s){super(t,e,r),this.center=s!=null?D(s):null}}class rt{constructor(t){this.layerUid=t}}let st=class extends rt{constructor(t,e){super(t),this.graphicUid=e}};function U(i){return(i==null?void 0:i.dist)!=null}const M=1e-5;class it{constructor(t){this.options=new F,this._results=new nt,this.transform=new Y,this.tolerance=M,this.verticalOffset=null,this._ray=p(),this._rayEnd=L(),this._rayBeginTransformed=L(),this._rayEndTransformed=L(),this.viewingMode=t??A.Global}get results(){return this._results}get ray(){return this._ray}get rayBegin(){return this._ray.origin}get rayEnd(){return this._rayEnd}reset(t,e,r){this.resetWithRay(q(t,e,this._ray),r)}resetWithRay(t,e){this.camera=e,t!==this._ray&&T(t,this._ray),this.options.verticalOffset!==0?this.viewingMode===A.Local?this._ray.origin[2]-=this.options.verticalOffset:this.verticalOffset=this.options.verticalOffset:this.verticalOffset=null,N(this._rayEnd,this._ray.origin,this._ray.direction),this._results.init(this._ray)}intersect(t=null,e,r,s,n){var h;this.point=e,this.filterPredicate=s,this.tolerance=r??M;const o=I(this.verticalOffset);if(t&&t.length>0){const u=n?a=>{n(a)&&this.intersectObject(a)}:a=>{this.intersectObject(a)};for(const a of t){const l=(h=a.getSpatialQueryAccelerator)==null?void 0:h.call(a);l!=null?(o!=null?l.forEachAlongRayWithVerticalOffset(this._ray.origin,this._ray.direction,u,o):l.forEachAlongRay(this._ray.origin,this._ray.direction,u),this.options.selectionMode&&this.options.hud&&l.forEachDegenerateObject(u)):a.objects.forAll(d=>u(d))}}this.sortResults()}intersectObject(t){const e=t.geometries;if(!e)return;const r=t.effectiveTransformation,s=I(this.verticalOffset);for(const n of e){if(!n.visible)continue;const{material:o,id:h}=n;if(!o.visible)continue;this.transform.setAndInvalidateLazyTransforms(r,n.transformation),R(this._rayBeginTransformed,this.rayBegin,this.transform.inverse),R(this._rayEndTransformed,this.rayEnd,this.transform.inverse);const u=this.transform.transform;s!=null&&(s.objectTransform=this.transform),o.intersect(n,this.transform.transform,this,this._rayBeginTransformed,this._rayEndTransformed,(a,l,d,y,g,b)=>{if(a>=0){if(this.filterPredicate!=null&&!this.filterPredicate(this._ray.origin,this._rayEnd,a))return;const c=y?this._results.hud:this._results,x=y?m=>{const W=new et(t,h,d,b);m.set(f.HUD,W,a,l,V,g)}:m=>m.set(f.OBJECT,{object:t,geometryId:h,triangleNr:d},a,l,u,g);if((c.min.drapedLayerOrder==null||g>=c.min.drapedLayerOrder)&&(c.min.dist==null||a<c.min.dist)&&x(c.min),this.options.store!==w.MIN&&(c.max.drapedLayerOrder==null||g<c.max.drapedLayerOrder)&&(c.max.dist==null||a>c.max.dist)&&x(c.max),this.options.store===w.ALL)if(y){const m=new B(this._ray);x(m),this._results.hud.all.push(m)}else{const m=new O(this._ray);x(m),this._results.all.push(m)}}})}}sortResults(t=this._results.all){t.sort((e,r)=>e.dist!==r.dist?(e.dist??0)-(r.dist??0):e.drapedLayerOrder!==r.drapedLayerOrder?j(e.drapedLayerOrder,r.drapedLayerOrder):j(e.drapedLayerGraphicOrder,r.drapedLayerGraphicOrder))}}function j(i,t){return(t??-Number.MAX_VALUE)-(i??-Number.MAX_VALUE)}function pt(i){return new it(i)}class nt{constructor(){this.min=new O(p()),this.max=new O(p()),this.hud={min:new B(p()),max:new B(p()),all:new Array},this.ground=new O(p()),this.all=[]}init(t){this.min.init(t),this.max.init(t),this.ground.init(t),this.all.length=0,this.hud.min.init(t),this.hud.max.init(t),this.hud.all.length=0}}class O{get ray(){return this._ray}get distanceInRenderSpace(){return this.dist!=null?(S(E,this.ray.direction,this.dist),P(E)):null}withinDistance(t){return!!U(this)&&this.distanceInRenderSpace<=t}getIntersectionPoint(t){return!!U(this)&&(S(E,this.ray.direction,this.dist),N(t,this.ray.origin,E),!0)}getTransformedNormal(t){return v(_,this.normal),_[3]=0,H(_,_,this.transformation),v(t,_),z(t,t)}constructor(t){this.intersector=f.OBJECT,this.normal=L(),this.transformation=k(),this._ray=p(),this.init(t)}init(t){this.dist=null,this.target=null,this.drapedLayerOrder=null,this.drapedLayerGraphicOrder=null,this.intersector=f.OBJECT,T(t,this._ray)}set(t,e,r,s,n,o,h){this.intersector=t,this.dist=r,v(this.normal,s??X),$(this.transformation,n??V),this.target=e,this.drapedLayerOrder=o,this.drapedLayerGraphicOrder=h}copy(t){T(t.ray,this._ray),this.intersector=t.intersector,this.dist=t.dist,this.target=t.target,this.drapedLayerOrder=t.drapedLayerOrder,this.drapedLayerGraphicOrder=t.drapedLayerGraphicOrder,v(this.normal,t.normal),$(this.transformation,t.transformation)}}class B extends O{constructor(){super(...arguments),this.intersector=f.HUD}}function at(i){return new O(i)}const E=L(),_=J();class ot extends st{constructor(t,e,r,s,n){super(t,e),this.layerUid=t,this.graphicUid=e,this.triangleNr=r,this.baseBoundingSphere=s,this.numLodLevels=n}}class ht{constructor(t,e,r,s){this.material=t,this.bufferWriter=t.createBufferWriter(),this.vertexBufferLayout=this.bufferWriter.vertexBufferLayout,this.buffer=e,this.elementCount=r,this.boundingInfo=s}get numTriangles(){return this.elementCount/3}get numVertices(){return this.elementCount}computeUsedMemory(){return this.buffer.byteLength+Q}getRenderGeometry(){return this}intersect(t,e,r,s,n,o,h,u){const a=this.bufferWriter,l=this.buffer;a.intersect(l,t,r,s,(d,y,g,b,c)=>C(d,y,g,c,t,e,o,h,n,u))}}class Ot{constructor(t){this.engineGeometry=t}get material(){return this.engineGeometry.material}get numVertices(){return this.engineGeometry.attributes.get(Z.POSITION).indices.length}get numTriangles(){return this.engineGeometry.indexCount/3}get boundingInfo(){return this.engineGeometry.boundingInfo}computeUsedMemory(){return Array.from(this.engineGeometry.attributes.values()).reduce((t,e)=>t+K(e.data,e.indices),0)}getRenderGeometry(){const t=this.material,e=this.engineGeometry,r=e.attributes,s=e.boundingInfo,n=t.createBufferWriter(),o=n.vertexBufferLayout,h=n.elementCount(r),u=o.createBuffer(h);return n.write(null,null,r,null,u,0),new ht(t,u.buffer,h,s)}intersect(t,e,r,s,n,o,h,u){const a=this.engineGeometry;this.material.intersect(a,t.transform.transform,t,r,s,(l,d,y,g,b)=>C(l,d,y,b,t,e,o,h,n,u))}}function C(i,t,e,r,s,n,o,h,u,a){if(i<0||n&&!n(s.rayBegin,s.rayEnd,i))return;const l=new ot(o.layerUid,o.graphicUid(u),e,h,a);if((s.results.min.drapedLayerOrder==null||r>=s.results.min.drapedLayerOrder)&&(s.results.min.dist==null||i<s.results.min.dist)&&s.results.min.set(f.LOD,l,i,t,s.transform.transform,r),s.options.store!==w.MIN&&(s.results.max.drapedLayerOrder==null||r>=s.results.max.drapedLayerOrder)&&(s.results.max.dist==null||i>s.results.max.dist)&&s.results.max.set(f.LOD,l,i,t,s.transform.transform,r),s.options.store===w.ALL){const d=at(s.results.min.ray);d.set(f.LOD,l,i,t,s.transform.transform,r),s.results.all.push(d)}}class _t{constructor(t,e=null){this.geometry=t,this.textures=e}get material(){return this.geometry.material}get numTriangles(){return this.geometry.numTriangles}}class Lt{constructor(t,e,r){this.components=t,this.minScreenSpaceRadius=e,this.pivotOffset=r;const s=G(this.components.map(n=>n.geometry));this.numVertices=s.reduce((n,o)=>n+o.numVertices,0)}}class bt{constructor(t){this.levels=t,this.levels.sort((e,r)=>e.minScreenSpaceRadius===r.minScreenSpaceRadius?e.numVertices-r.numVertices:e.minScreenSpaceRadius-r.minScreenSpaceRadius)}getMaterials(){const t=[];return this.levels.forEach(e=>e.components.forEach(r=>t.push(r.geometry.material))),G(t)}getTextures(){const t=new Array;return this.levels.forEach(e=>e.components.forEach(r=>{r.textures!=null&&t.push(...r.textures)})),G(t)}getGeometries(){const t=new Array;return this.levels.forEach(e=>e.components.forEach(r=>{t.push(r.geometry)})),G(t)}getEngineGeometries(){return this.getGeometries().map(t=>t.engineGeometry).filter(t=>t!=null)}computeUsedMemory(){const t=this.getGeometries(),e=this.getTextures(),r=t.reduce((s,n)=>s+n.computeUsedMemory(),0);return e.reduce((s,n)=>s+n.memoryEstimate,0)+r}}export{pt as T,Ot as a,Lt as f,bt as h,_t as l,ht as m};
